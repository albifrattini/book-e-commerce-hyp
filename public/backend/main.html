<html>
   <head>
      <title>Book store</title>
   </head>
   <body>
      <h1 id="documentation-of-the-backend-part">Documentation of the Backend part</h1>
      <blockquote>
         <p>Deliverable D1</p>
      </blockquote>
      <h2 id="general-group-information">General group information</h2>
      <table>
         <thead>
            <tr class="header">
               <th>Member n.</th>
               <th>Role</th>
               <th>First name</th>
               <th>Last Name</th>
               <th>Matricola</th>
               <th>Email address</th>
            </tr>
         </thead>
         <tbody>
            <tr class="odd">
               <td>1</td>
               <td>administrator</td>
               <td>Alberto</td>
               <td>Frattini</td>
               <td>898440</td>
               <td>alberto.frattini@mail.polimi.it</td>
            </tr>
            <tr class="even">
               <td>2</td>
               <td>member</td>
               <td>Gabriele</td>
               <td>Ghiringhelli</td>
               <td>914499</td>
               <td>gabriele.ghiringhelli@mail.polimi.it</td>
            </tr>
         </tbody>
      </table>
      <h2 id="links-to-other-deliverables">Links to other deliverables</h2>
      <ul>
         <li>
            <p>D0: the web application is accessible at <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/">this address</a>.</p>
         </li>
         <li>
            <p>D2: the YAML file containing the specification of the app API can be found at <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/backend/spec.yaml">this address</a>.</p>
         </li>
         <li>
            <p>D3: the SwaggerUI page of the same API is available at <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/backend/swaggerui">this address</a>.</p>
         </li>
         <li>
            <p>D4: the source code of D0 is available as a zip file at <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/backend/app.zip">this address</a>.</p>
         </li>
         <li>
            <p>D5: the address of the online source control repository is available <a href="https://github.com/albifrattini/book-e-commerce-hyp">this address</a>. We hereby declare that this is a private repository and we have given access to the instructors (Vittorio Zaccaria).</p>
         </li>
      </ul>
      <h2 id="specification">Specification</h2>
      <h3 id="web-architecture">Web Architecture</h3>
      <img src="3-tier-arch.jpg" width="1000">
      <p>As we can see in the picture, we are using a 3-tier architecture, dividing the client from the server and the database. The database is accessible only from the server. Thanks to the REST API that we have built, we made really easy accessing the data. When a request is performed from the client to the server, the HTML code is sent back to the client with some JS scripts that lets us render the page in the client-side, adapting contents to the user. Futhermore, some scripts help us performing filtering and rendering depending from the user interaction with the website. For example, in our Books page, we send some HTML code but we need to perform other requests and some rendering to be able to show to the user the books that she is looking for.</p>
      <h3 id="api">API</h3>
      <h4 id="rest-compliance">REST compliance</h4>
      <p>In our project we are following the REST principles:</p>
        We have implemented a client-server architecture where the client is not seeing directly the database and all informations stored on the server but can demand for them through specific requests to the server and so to the backend implementation of the application. This decision, indeed, is allowing the two entities to evolve indipendently. In particular, thanks to the specified methods POST, GET and DELETE we are able to perform all the actions that we need: requesting informations, adding data to the database and delete something from it. In our project we decided to use sessions to manage the authentication of the user to allow this one to access some specific resources, in particular the personal cart where she can put the books she is interested in buying. Furthermore, some of these informations can be cached in order to speed up all the computation. Using the three-tier architecture we could achieve the division of the client from the server and so the database. In principle, between the client and the server, there is our RESTful API that is allowing anyone to retrieve the specific information that is needed from the database.
      <h4 id="openapi-resource-models">OpenAPI Resource models</h4>
      <p>In our project we used 5 main Resource models:</p>
      <ul>
        <li>Book - represents a book available in our inventory.</li>
        <li>Author - represents an author that has written some book available in our inventory.</li>
        <li>Event - represents an event where a book is presented by the author.</li>
        <li>User - represents a possible user of the platform; registration is required to use and access the Cart.</li>
        <li>Cart - represents the personal cart of user, where books can be put and then purchased.</li>
      </ul>
      <h3 id="data-model">Data model</h3>
      <img src="er-diagram.png">
      <p>As we can see in the ER diagram, we have 5 main entities, connected between them with specific relationships. As it is defined above, the models are: Book, Author, Event, User and Cart. In the OpenAPI Resource models, relationships are not specified, but the diagram can give a clear idea on the way these entities are connected and how they can provide the data to the Front End of the application.</p>
      <h2 id="implementation">Implementation</h2>
      <h3 id="tools-used">Tools used</h3>
      <p>Tools, languages and frameworks used for the backend of the application:</p>
      <ul>
        <li>JavaScript as main programming language.</li>
        <li>Node.js as run-time environment.</li>
        <li>Swagger framework for the documentation and implementaion of some parts of the API.</li>
        <li>PostgreSQL as database.</li>
        <li>Main NPM modules: express, express-session, swagger-tools, knex, pg, bcrypt and joi.</li>
      </ul>
      <h3 id="discussion">Discussion</h3>
      <ul>
         <li>Using Swagger, we could achieve an ordered and clear REST API. All the endpoints are specified in the document and can be seen accessing <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/backend/swaggerui">this path</a>. All the data that gets to the backend is validated in order to face specifications that we fixed.</li>
         <li>We divided our project into many folders to make it tidy and clear for future interventions and maintenance. In principle, we are storing all the backend part of the project in the root folder and all the static files inside a specific folder, called 'public'. This organization of the folders is for sure one of the best ones to adopt because is making pretty clear where files are stored and how the HTML part communicates with CSS and JS code.</li>
         <li>There are two action that can be performed only if a user is registered and logged into the platform: Adding and checking the cart. To do so, we have used ‘express-session’ and, attaching a parameter to the request coming towards the server, we could check if the user is logged in and who this user is and show the content of the cart accor</li>
      </ul>
      <h2 id="other-information">Other information</h2>
      <h3 id="task-assignment">Task assignment</h3>
      <ul>
      <li>Alberto worked on front end (30%) and OpenAPI Spec (80% of the time)</li>
      <li>Gabriele worked on front end (70%) and OpenAPI Spec (20% of the time)</li>
      </ul>
      <h3 id="analysis-of-existing-api">Analysis of existing API</h3>
      <p>In principle, to design our RESTful API with Swagger, we have taken into account a couple of examples. To understand and start creating our API with the Swagger tool, we used the SwaggerUI example about the Petstore. It had been useful to understand the basic principles of the tool but also to start appreciating the tidiness of the documentation that is automatically generated. We also used the Professor's examples to start having an idea on how the backend part is implemented and, thanks to many videos and articles on REST APIs, we could finally achieve and create our own.</p>
      <h3 id="learning-outcome">Learning outcome</h3>
      <p>What was the most important thing all the members have learned while developing this part of the project, what questions remained unanswered, how you will use what you’ve learned in your everyday life?</p>
      <p>Examples: - Foo learned to write SQL queries and Javascript but wanted to know more about caching, he’s probably going to create his own startup with what she has learned - Bar learned how to deploy on a cloud platform, he would have liked to know more about promises for asynchronous code..</p>
   </body>