<html>
   <head>
      <title>Book store</title>
   </head>
   <body>
      <h1 id="documentation-of-the-backend-part">Documentation of the Backend part</h1>
      <blockquote>
         <p>Deliverable D1</p>
      </blockquote>
      <h2 id="general-group-information">General group information</h2>
      <table>
         <thead>
            <tr class="header">
               <th>Member n.</th>
               <th>Role</th>
               <th>First name</th>
               <th>Last Name</th>
               <th>Matricola</th>
               <th>Email address</th>
            </tr>
         </thead>
         <tbody>
            <tr class="odd">
               <td>1</td>
               <td>administrator</td>
               <td>Alberto</td>
               <td>Frattini</td>
               <td>898440</td>
               <td>alberto.frattini@mail.polimi.it</td>
            </tr>
            <tr class="even">
               <td>2</td>
               <td>member</td>
               <td>Gabriele</td>
               <td>Ghiringhelli</td>
               <td>914499</td>
               <td>gabriele.ghiringhelli@mail.polimi.it</td>
            </tr>
         </tbody>
      </table>
      <h2 id="links-to-other-deliverables">Links to other deliverables</h2>
      <ul>
         <li>
            <p>D0: the web application is accessible at <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/">this address</a>.</p>
         </li>
         <li>
            <p>D2: the YAML file containing the specification of the app API can be found at <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/backend/spec.yaml">this address</a>.</p>
         </li>
         <li>
            <p>D3: the SwaggerUI page of the same API is available at <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/backend/swaggerui">this address</a>.</p>
         </li>
         <li>
            <p>D4: the source code of D0 is available as a zip file at <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/backend/app.zip">this address</a>.</p>
         </li>
         <li>
            <p>D5: the address of the online source control repository is available <a href="https://github.com/albifrattini/book-e-commerce-hyp">this address</a>. We hereby declare that this is a private repository and we have given access to the instructor (Vittorio Zaccaria).</p>
         </li>
      </ul>
      <h2 id="specification">Specification</h2>
      <h3 id="web-architecture">Web Architecture</h3>
      <img src="3-tier-arch.jpg" width="1000">
      <p>As we can see in the picture, we are using a 3-tier architecture, dividing the client from the server and the database. The database is accessible only from the server. Thanks to the REST API that we have built, we made really easy accessing the data. When a request is performed from the client to the server, the HTML code is sent back to the client with some JS scripts that lets us render the page in the client-side, adapting contents to the user. Futhermore, some scripts help us performing filtering and rendering depending from the user interaction with the website. For example, in our Books page, we send some HTML code but we need to perform other requests, when a filter is triggered, and some rendering to be able to show to the user the books that she is looking for. The parts belonging to the presentation layer are the HTML, JS and CSS files that are sent back to the client when a request towards the application layer is performed. In general, the user cannot see all the code that is executed in the application layer since only what is needed is sent back to the user. In the application layer instead, we have the REST API and the server that we are using to execute code and requests coming from the clients. In particular, thanks to the way these APIs are built, only specific requests can be performed by the client and they can be triggered while interacting with the website. The data layer, finally, holds all the data necessary to show content to the client. Everytime there is a request for some page, further requests are executed through JS scripts and the data returned is rendered to fit the specific layout of the page. All the data returned, follow a specific structure that is specified in the API.</p>
      <h3 id="api">API</h3>
      <h4 id="rest-compliance">REST compliance</h4>
      <p>In our project we are following the REST principles:</p>
        We have implemented a client-server architecture where the client is not seeing directly the database and all informations stored on the server but can demand for them through specific requests to the server and so to the backend implementation of the application. This decision, indeed, is allowing the two entities to evolve indipendently. In particular, thanks to the specified methods POST, GET and DELETE we are able to perform all the actions that we need: requesting informations, adding data to the database and delete something from it. In our project we decided to use sessions to manage the authentication of the user and to allow this one to access some specific resources, in particular the personal cart where she can put the books she is interested in buying. Furthermore, some of these informations can be cached in order to speed up all the computation. Using the three-tier architecture we could achieve the division of the client from the server and so the database. In principle, between the client and the server, there is our RESTful API that is allowing anyone to retrieve the specific information that is needed from the database.
      <h4 id="openapi-resource-models">OpenAPI Resource models</h4>
      <p>In our project we used 5 main Resource models:</p>
      <ul>
        <li>Book - represents a book available in our inventory.</li>
        <li>Author - represents an author that has written some book available in our inventory.</li>
        <li>Event - represents an event where a book is presented by the author.</li>
        <li>User - represents a possible user of the platform; registration is required to use and access the Cart.</li>
        <li>Cart - represents the personal cart of user, where books can be put and then purchased.</li>
      </ul>
      <h3 id="data-model">Data model</h3>
      <img src="er-diagram.png">
      <p>As we can see in the ER diagram, we have 5 main entities, connected between them with specific relationships. As it is defined above, the models are: Book, Author, Event, User and Cart. In the OpenAPI Resource models, relationships are not specified, but the diagram can give a clear idea on the way these entities are connected and how they can provide the data to the client-side of the application.</p>
      <h2 id="implementation">Implementation</h2>
      <h3 id="tools-used">Tools used</h3>
      <p>Tools, languages and frameworks used for the backend of the application:</p>
      <ul>
        <li>JavaScript as main programming language.</li>
        <li>Node.js as run-time environment.</li>
        <li>Swagger framework for the documentation and implementaion of some parts of the API.</li>
        <li>PostgreSQL as database.</li>
        <li>Main NPM modules: express, express-session, swagger-tools, knex, pg, bcrypt and joi.</li>
      </ul>
      <h3 id="discussion">Discussion</h3>
      <ul>
         <li>Using Swagger, we could achieve an ordered and clear REST API. All the endpoints are specified in the document and can be seen accessing <a href="https://polimi-hyp-2019-team-10496529.herokuapp.com/backend/swaggerui">this path</a>. All the data that gets to the backend is validated in order to face specifications that we fixed.</li>
         <li>We divided our project into many folders to make it tidy and clear for future interventions and maintenance. In principle, we are storing all the backend part of the project in the root folder and all the static files inside a specific folder, called 'public'. This organization of the folders is for sure one of the best ones to adopt because is making pretty clear where files are stored and how the HTML part communicates with CSS and JS code. There can be other structures that may meet our requirements, but when we started working on the project, we thought this organization could make us work efficiently because it is easy to understand and makes simple the access to all fundamental files.</li>
         <li>There are two action that can be performed only if a user is registered and logged into the platform: Adding and checking the cart. To do so, we have used ‘express-session’ and, attaching a parameter to the request coming towards the server, we could check if the user is logged in and who this user is and show the content of the cart accordingly. There are 2 main trigerring actions: POST to login with email and password; GET to logout. In particular, we didn't know which action could fit the best what we wanted to achieve with logout since the only action performed in the backend is the deletion of the session.</li>
         <li>We decided to adopt a Relation database for two reasons: relational databases are widely spread all over web applications and not only; it was suggested by the instructors and it was the model we have been using for many years since we enrolled in Politecnico. In general, we can say that No-Sql databases can be used and may be really efficient. In following projects, we may be interested in trying GraphQL since it's an arising technology but already well spread technology.</li>
      </ul>
      <h2 id="other-information">Other information</h2>
      <h3 id="task-assignment">Task assignment</h3>
      <ul>
      <li>Alberto worked on front end (30%) and OpenAPI Spec (80% of the time)</li>
      <li>Gabriele worked on front end (70%) and OpenAPI Spec (20% of the time)</li>
      </ul>
      <h3 id="analysis-of-existing-api">Analysis of existing API</h3>
      <p>In principle, to design our RESTful API with Swagger, we have taken into account a couple of examples. To understand and start creating our API with the Swagger tool, we used the SwaggerUI example about the Petstore. It had been useful to understand the basic principles of the tool but also to start appreciating the tidiness of the documentation that is automatically generated. We also used the Professor's examples to start having an idea on how the backend part is implemented and, thanks to many videos and articles on REST APIs, we could finally achieve and create our own.</p>
      <h3 id="learning-outcome">Learning outcome</h3>
        <li>Alberto and Gabriele learned how to deploy an application to a cloud platform and liked how simple it was and how powerful can be updating the code locally and seeing immediately, on every device, all the changes made in the code. In particular, it could be interesting to exploit many more add-ons provided by Heroku, for example, to do some data analysis and many more things. In general, we would like to investigate more how an application in a business environment is done, with all the more complicated parts that come with it.</li>
        <li>Gabriele appreciated working with NodeJS and its simplicity and complete set of modules. He would like to dig down more into the functionalities of the run-time environment, trying to understand which modules are the most used in production.</li>
        <li>Alberto and Gabriele would like to use other programming languages and web frameworks, such as Django, to start understanding which one is the most suitable for the specific application that we have to deal with. In the future, we are interested in building other websites to learn many more things and develop a great knowledge in the web development world.</li>
        <li>Alberto have learned how to manage Swagger and really liked the outcome of the documentation automatically generated by it. It had been difficult to understand all the processes that guided a request towards the specific section responding to it, but now would like to develop more difficult websites, in order to be able to face all the specifications that can be encountered during a real world job.</li>
        <li>Alberto would like to discover new technologies used for the data storage. In particular, GraphQL could be an interesting solution to try since many companies are now changing from the standard. In particular, it is fascinating how is making requests easy and filters all the necessary data.</li>
        <li>Alberto, in general, would like to face a real-world scenario and develop an application to learn new technologies, become more confident in using some tools and understanding which technology is the best one for the specific setting.</li>
      </ul>
   </body>